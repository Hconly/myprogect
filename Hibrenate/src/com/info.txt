hibernate  主键 自然主键  本身属于表的一部分内容 属于表的字段

1.代理主键  人为的添加一个主键  开发多用 代理主键
自然主键参与业务逻辑容易造成源代码被修改   好程序要满足开闭原则
主键一般只作为条件只参与查询不参与修改


主键的生成策略：increment：long int short  只适用于单线程
使用原则select max(id)from 表 查询当前主键并加1

identity：MySQL  数据库底层自动增长  Oracle没有
sequence：序列 Oracle
uuid：字符串类型的主键
native：自动识别sequence 和 identity
assigned：不会自动管理手动管理主键

开发经常使用 uuid native

2.持久化类  Java类+映射  必须添加无参构造（通过反射创建，没有无参构造无法反射创建对象）
持久化类的对象的三种状态：
瞬时态 刚创建的类 还没有交给session管理 没有自己的id
持久态：被session管理的对象类，没有close之前 可以自动更新数据库
游离态：session关闭之后的处于游离态

三种状态之间的转换 看图片

hibernate 缓存
一级缓存：
   session级别的缓存生命周期与session一致 默认从session创建存在
   b不可卸载 调用load get list等时候会判断缓存中是否存在 如果存在
   直接使用 如果不存在去数据库调用 并将其写入一级缓存中便于使用

为什么可以自动存储 ：hibernate存在 快照区会进行对比 一致就使用不一致就更新并更新缓存
二级缓存：一般不适用自己的缓存使用redis


3.设置事务隔离级别
在hibernate.cfg.xml添加配置
<property name="hibernate.connection.isolation">4</property>
事务设置位置
一般在业务层设置事务 开启事务 提交事务
在service层
保证DAO层与service层的session是同一个session
session对象绑定一个Thread Local 相当于一个客户的操作
每个人开启一个线程
hibernate处理方法：hibernate内部绑定了一个threadlocal
<property name="current_session_context_class">thread</pr
创建一个session绑定到当前线程
直接使用sessionFactory调用getCurrentSession()不用openSession ()

hibernate   表与表之间的关系
一对多 多对多 一对一
一对多 多的一方建立外键对应一的一方
多对多之间存在一个中间关系
